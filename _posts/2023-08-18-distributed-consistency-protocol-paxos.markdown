---
layout: post
title:  "分布式一致性协议之—Paxos"
date:   2023-08-18 15:40:56
categories: jekyll update
---

### 一、前提知悉
#### Quorum机制
##### Quorum概念
Quorum思想用一句话解释就是，在N个副本中，一次更新成功的如果有M个，读取数据时要从大于N-M个副本中读取，这样就能至少读取到一个更新的数据了。  
和Quorum对应的是WARO，也就是Write All Read One，是一种简单的副本控制协议，当Client请求向副本写数据时（更新数据），只有当所有副本都更新成功，这次写操作才算成功，否则算失败，WARO优先保证读服务，因为所有副本更新成功，才能视为更新成功，从而保证了所有副本一致，这样的话，只要读取任何一个副本上的数据即可。写服务的可用性较低，因为只要一个副本更新失败，此次写操作就失败了。假设有N个副本，N-1个都宕机了，剩下的那个副本还可以提供读服务；但只要有一个副本宕机了，写服务就不会成功。  
WARO牺牲了更新服务的可用性，最大程度保证了读服务的可用性，而Quorum就是在更新服务和读服务之间进行的一个折衷  

##### Quorum定义
N = 副本数量  
M = 更新成功的副本  
R = 一次数据对象读取要访问的副本的数量
Quorum就是限定了一次需要至少读取N+1-W的副本数据， 举个例子，我们维护了 10 个副本，一次成功更新了三个，那么至少需要读取八个副本的数据，可以保证我们读到了最新的数据。

##### Quorum应用
Quorum机制无法保证强一致性，也就是说无法保证任何时刻任何用户都可以读到最近一次成功提交的副本数据。Quorumj机制的使用需要配合一个获取最新成功提交的版本号的metadata服务，这样可以确认最新已经提交的版本号，然后从已经读到的数据中就可以确认最新写入的数据。  

Quorum是分布式系统中常用的一种机制，用来保证数据冗余和最终一致性的投票算法，在Paxos、Raft和zookeeper的Zab等算法中，都可以看到Quorum机制的应用

#### 要素详解
##### 基本可用
基本可用就是不追求CAP中「任何时候，读写都是成功的」，而是系统能够基本运行，一直提供服务。强调了分布式系统在出现不可预知的故障的时候，允许损失部分可用性，
相比正常的系统，允许损失部分可用性，相比正常的系统，可能是响应时间过长，或者服务降级。举个例子，在双十一秒杀活动中，如果抢购人数超过了系统QPS峰值，可能会排队或者
限流，通过合理手段保护系统的稳定性，保证主要的服务正常，保证基本可用
##### 软状态
对应ACID事务的原子性，在ACID事务中，实现的是事务的强一致性，要么全做要么不做，所有用户看到的数据一致。其中原子性要求多个节点的数据副本是一致的，强调数据的一致性。原子性
可以理解为一种"硬状态"，软状态则允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，允许多个不同节点的数据副本存在延时
##### 最终一致性
数据不可能一直是软状态，必然会在一定时间期限之后达到各个节点的一致性，期限过后，应当保证所有副本保持数据一致性，也就是达到数据的最终一致性。
在系统设计中，最终一致性实现时间取决于网络延时、系统负载、不同的存储选型、不同数据复制方案设计等因素

### 二、不同数据一致性模型
一般来说，数据一致性分为强一致性和弱一致性，强一致性也叫线性一致性，除此之外，其它所有的一致性都是弱一致性。  
弱一致性根据不同业务场景，又可以分解为更细分的模型。在互联网的绝大多数场景中，都需要牺牲强一致性换取系统的高可用性系统往往只需保证最终一致性，只要这个最终时间是在用户可接受范围内
![一致性](https://github.com/xuxing421/imageBed/assets/56280293/b9565cba-4140-4731-a8de-6e5dde065fab)
#### 强一致性
当更新完成操作之后，任何后续进程的访问都会返回最新的值，这种对用户是友好的，就是用户上一次写什么，下一次就能读到什么。根据CAP理论，这种实现需要实现可用性
#### 弱一致性
系统在数据写入成功后，不承若立即读到最新的值，也不承诺多久之后可以读到。用户读到某一操作对系统数据的更新需要一段时间，我们称这段时间叫不一致窗口
#### 最终一致性
最终一致性是弱一致性的特例，强调的是所有的数据副本，再经过一段时间的同步之后，最终能达到一个一致的状态。因此，最终一致性是需要系统保证最终能达到一致的，而不需要实时保证系统的强一致性。不一致窗口时间，主要受通信延时、系统负载和复制副本的个数影响。最终一致性按照其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性
##### 因果一致性
因果一致性要求有因果关系的操作顺序得到保证。举个例子，在微博或者微信进行评论的时候，比如你在朋友圈发了一张照片，朋友给你评论了，而你对朋友的评论进行了回复，这条朋友圈的显示中，你的回复必须在朋友之后，这是一个因果关系，而其他没有因果关系的数据，可以允许不一致。
##### 会话一致性
系统一致性将对数据的访问过程框定在了一个会话当中，约定了系统能保证在一个有效的会话中实现"读己之所写"的一致性，就是在你的一次访问中，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。实际开发中有分布式的 Session 一致性问题，可以认为是会话一致性的一个应用。

### BASE和CAP的关系
BASE是基于CAP发展的，CAP理论描述了分布式系统在一致性、可用性和分区容错性之间的制约关系，当选择了其中两个时，就不得不对剩下的一个做一定程度的牺牲。  
BASE理论是对CAP理论的实际应用，也就是在分区和副本存在的前提下，通过一定的系统设计，放弃强一致性，实现基本可用，这也是大部分分布式系统的选择，比如NoSQL系统，微服务架构。  
在实际场景中，不同业务对数据的一致性要求不同。BASE理论面向的是高可用、可扩展的分布式系统，ACID适合传统金融业务
