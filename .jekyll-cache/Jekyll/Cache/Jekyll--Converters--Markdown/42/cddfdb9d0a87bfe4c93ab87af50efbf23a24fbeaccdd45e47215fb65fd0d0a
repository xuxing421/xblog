I"<h3 id="一前提知悉">一、前提知悉</h3>
<h4 id="base理论">BASE理论</h4>
<h5 id="概念">概念</h5>
<p>BASE是三个短语的简写，即基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）</p>

<p>BASE理论的核心是最终一致性，即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式使系统达到最终一致性</p>

<h4 id="要素详解">要素详解</h4>
<h5 id="基本可用">基本可用</h5>
<p>基本可用就是不追求CAP中「任何时候，读写都是成功的」，而是系统能够基本运行，一直提供服务。强调了分布式系统在出现不可预知的故障的时候，允许损失部分可用性，
相比正常的系统，允许损失部分可用性，相比正常的系统，可能是响应时间过长，或者服务降级。举个例子，在双十一秒杀活动中，如果抢购人数超过了系统QPS峰值，可能会排队或者
限流，通过合理手段保护系统的稳定性，保证主要的服务正常，保证基本可用</p>
<h5 id="软状态">软状态</h5>
<p>对应ACID事务的原子性，在ACID事务中，实现的是事务的强一致性，要么全做要么不做，所有用户看到的数据一致。其中原子性要求多个节点的数据副本是一致的，强调数据的一致性。原子性
可以理解为一种”硬状态”，软状态则允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，允许多个不同节点的数据副本存在延时</p>
<h5 id="最终一致性">最终一致性</h5>
<p>数据不可能一直是软状态，必然会在一定时间期限之后达到各个节点的一致性，期限过后，应当保证所有副本保持数据一致性，也就是达到数据的最终一致性。
在系统设计中，最终一致性实现时间取决于网络延时、系统负载、不同的存储选型、不同数据复制方案设计等因素</p>

<h3 id="二不同数据一致性模型">二、不同数据一致性模型</h3>
<p>一般来说，数据一致性分为强一致性和弱一致性，强一致性也叫线性一致性，除此之外，其它所有的一致性都是弱一致性。<br />
弱一致性根据不同业务场景，又可以分解为更细分的模型。在互联网的绝大多数场景中，都需要牺牲强一致性换取系统的高可用性系统往往只需保证最终一致性，只要这个最终时间是在用户可接受范围内
<img src="https://github.com/xuxing421/imageBed/assets/56280293/b9565cba-4140-4731-a8de-6e5dde065fab" alt="一致性" /></p>
<h4 id="强一致性">强一致性</h4>
<p>当更新完成操作之后，任何后续进程的访问都会返回最新的值，这种对用户是友好的，就是用户上一次写什么，下一次就能读到什么。根据CAP理论，这种实现需要实现可用性</p>
<h4 id="弱一致性">弱一致性</h4>
<p>系统在数据写入成功后，不承若立即读到最新的值，也不承诺多久之后可以读到。用户读到某一操作对系统数据的更新需要一段时间，我们称这段时间叫不一致窗口</p>
<h4 id="最终一致性-1">最终一致性</h4>
<p>最终一致性是弱一致性的特例，强调的是所有的数据副本，再经过一段时间的同步之后，最终能达到一个一致的状态。因此，最终一致性是需要系统保证最终能达到一致的，而不需要实时保证系统的强一致性。不一致窗口时间，主要受通信延时、系统负载和</p>
:ET